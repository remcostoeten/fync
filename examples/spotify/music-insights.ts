import { Spotify } from '@remcostoeten/fync/spotify';

type TMusicInsights = {
  topArtists: any[];
  topTracks: any[];
  recentlyPlayed: any[];
  musicalDiversity: number;
  listeningHabits: {
    averageTrackLength: number;
    preferredGenres: string[];
    activityPeriods: string[];
  };
};

async function generateMusicInsights(): Promise<TMusicInsights> {
  const spotify = Spotify({ 
    token: process.env.SPOTIFY_ACCESS_TOKEN,
    cache: true 
  });

  const [recentTracks, savedTracks, followedArtists] = await Promise.all([
    spotify.me.recentlyPlayed.get({ params: { limit: 50 } }),
    spotify.me.tracks.get({ params: { limit: 50 } }),
    spotify.me.artists.get({ params: { limit: 50 } })
  ]);

  const topArtists = extractTopArtists(recentTracks.items);
  const topTracks = extractTopTracks(savedTracks.items);
  const musicalDiversity = calculateMusicalDiversity(recentTracks.items);
  const listeningHabits = analyzeListeningHabits(recentTracks.items);

  return {
    topArtists,
    topTracks,
    recentlyPlayed: recentTracks.items.slice(0, 10),
    musicalDiversity,
    listeningHabits
  };
}

function extractTopArtists(recentTracks: any[]): any[] {
  const artistCounts = new Map<string, { artist: any; count: number }>();

  for (const item of recentTracks) {
    const artist = item.track.artists[0];
    const existing = artistCounts.get(artist.id);
    
    if (existing) {
      existing.count++;
    } else {
      artistCounts.set(artist.id, { artist, count: 1 });
    }
  }

  return Array.from(artistCounts.values())
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);
}

function extractTopTracks(savedTracks: any[]): any[] {
  return savedTracks
    .map(item => item.track)
    .sort((a, b) => b.popularity - a.popularity)
    .slice(0, 10);
}

function calculateMusicalDiversity(recentTracks: any[]): number {
  const uniqueArtists = new Set(recentTracks.map(item => item.track.artists[0].id));
  const uniqueGenres = new Set();
  
  for (const item of recentTracks) {
    for (const artist of item.track.artists) {
      if (artist.genres) {
        for (const genre of artist.genres) {
          uniqueGenres.add(genre);
        }
      }
    }
  }

  const artistDiversity = uniqueArtists.size / recentTracks.length;
  const genreDiversity = uniqueGenres.size / 50;
  
  return Math.min((artistDiversity + genreDiversity) * 50, 100);
}

function analyzeListeningHabits(recentTracks: any[]) {
  const trackLengths = recentTracks.map(item => item.track.duration_ms);
  const averageTrackLength = trackLengths.reduce((sum, length) => sum + length, 0) / trackLengths.length;

  const playTimes = recentTracks.map(item => new Date(item.played_at));
  const hourCounts = new Map<number, number>();

  for (const time of playTimes) {
    const hour = time.getHours();
    hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);
  }

  const activityPeriods = Array.from(hourCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([hour]) => {
      if (hour >= 6 && hour < 12) return 'Morning';
      if (hour >= 12 && hour < 18) return 'Afternoon';
      if (hour >= 18 && hour < 22) return 'Evening';
      return 'Night';
    });

  return {
    averageTrackLength: Math.round(averageTrackLength / 1000),
    preferredGenres: [],
    activityPeriods: [...new Set(activityPeriods)]
  };
}

async function createSmartPlaylist(seedTracks: string[], playlistName: string) {
  const spotify = Spotify({ token: process.env.SPOTIFY_ACCESS_TOKEN });

  const recommendations = await spotify.api.recommendations.get({
    params: {
      seed_tracks: seedTracks.slice(0, 5).join(','),
      limit: 30,
      target_energy: 0.7,
      target_valence: 0.6
    }
  });

  const user = await spotify.me.get();
  const playlist = await spotify.api.users[user.id].playlists.post({
    name: playlistName,
    description: `Smart playlist generated by Fync based on your listening habits`,
    public: false
  });

  const trackUris = recommendations.tracks.map((track: any) => track.uri);
  await spotify.playlist(playlist.id).tracks.add(trackUris);

  return {
    playlist,
    tracks: recommendations.tracks,
    trackCount: trackUris.length
  };
}

async function discoverNewMusic(genres: string[] = ['indie', 'electronic']) {
  const spotify = Spotify({ token: process.env.SPOTIFY_ACCESS_TOKEN });

  const discoveries = await Promise.all(
    genres.map(async genre => {
      const results = await spotify.search.tracks(`genre:${genre}`, {
        params: { limit: 20 }
      });

      return {
        genre,
        tracks: results.tracks.items
          .filter((track: any) => track.popularity > 30 && track.popularity < 70)
          .slice(0, 10)
      };
    })
  );

  return discoveries.filter(discovery => discovery.tracks.length > 0);
}

async function analyzePlaylistHealth(playlistId: string) {
  const spotify = Spotify({ token: process.env.SPOTIFY_ACCESS_TOKEN });

  const [playlist, tracks] = await Promise.all([
    spotify.playlist(playlistId).get(),
    spotify.playlist(playlistId).tracks.get({ params: { limit: 100 } })
  ]);

  const artistCounts = new Map<string, number>();
  const decadeCounts = new Map<string, number>();
  let totalDuration = 0;

  for (const item of tracks.items) {
    const track = item.track;
    totalDuration += track.duration_ms;

    const artist = track.artists[0];
    artistCounts.set(artist.id, (artistCounts.get(artist.id) || 0) + 1);

    const releaseYear = new Date(track.album.release_date).getFullYear();
    const decade = `${Math.floor(releaseYear / 10) * 10}s`;
    decadeCounts.set(decade, (decadeCounts.get(decade) || 0) + 1);
  }

  const duplicateArtists = Array.from(artistCounts.values()).filter(count => count > 1).length;
  const diversityScore = Math.max(0, 100 - (duplicateArtists / tracks.items.length) * 100);

  return {
    playlist,
    totalTracks: tracks.items.length,
    totalDuration: Math.round(totalDuration / (1000 * 60)),
    diversityScore: Math.round(diversityScore),
    topDecades: Array.from(decadeCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3),
    duplicateArtists,
    recommendations: {
      removeDuplicates: duplicateArtists > 5,
      addMoreVariety: diversityScore < 70,
      shortenPlaylist: tracks.items.length > 100
    }
  };
}

async function findConcertRecommendations(location: string = 'New York') {
  const spotify = Spotify({ token: process.env.SPOTIFY_ACCESS_TOKEN });

  const [recentTracks, followedArtists] = await Promise.all([
    spotify.me.recentlyPlayed.get({ params: { limit: 50 } }),
    spotify.me.artists.get({ params: { limit: 50 } })
  ]);

  const favoriteArtists = new Set([
    ...followedArtists.artists.items.map((artist: any) => artist.name),
    ...recentTracks.items.map((item: any) => item.track.artists[0].name)
  ]);

  return Array.from(favoriteArtists).slice(0, 20).map(artist => ({
    artist,
    location,
    searchQuery: `${artist} concert ${location}`,
    spotifyUrl: `https://open.spotify.com/search/${encodeURIComponent(artist)}`
  }));
}

export {
  generateMusicInsights,
  createSmartPlaylist,
  discoverNewMusic,
  analyzePlaylistHealth,
  findConcertRecommendations
};
